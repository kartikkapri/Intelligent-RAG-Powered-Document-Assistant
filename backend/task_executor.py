"""
Task Executor Module
Handles execution of various tasks like email, file operations, browser actions, etc.
"""

import os
import json
import smtplib
import webbrowser
import subprocess
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from typing import Dict, List, Optional, Any
from datetime import datetime
from pathlib import Path
import requests


class TaskExecutor:
    """Executes various types of tasks"""
    
    def __init__(self, output_dir: str = "agent_outputs"):
        self.output_dir = Path(output_dir)
        self.output_dir.mkdir(exist_ok=True)
        self.execution_log = []
        
    def log_execution(self, task_type: str, task_data: Dict, result: Dict):
        """Log task execution for debugging"""
        self.execution_log.append({
            "timestamp": datetime.now().isoformat(),
            "task_type": task_type,
            "task_data": task_data,
            "result": result
        })
    
    async def execute_email_task(
        self, 
        recipient: str, 
        subject: str, 
        body: str,
        smtp_config: Optional[Dict] = None
    ) -> Dict[str, Any]:
        """
        Execute email task - generate and send email
        
        Args:
            recipient: Email recipient
            subject: Email subject
            body: Email body (can be generated by AI)
            smtp_config: SMTP configuration (host, port, username, password)
        
        Returns:
            Execution result
        """
        try:
            # Default SMTP config (can be overridden)
            config = smtp_config or {
                "host": os.getenv("SMTP_HOST", "smtp.gmail.com"),
                "port": int(os.getenv("SMTP_PORT", "587")),
                "username": os.getenv("SMTP_USERNAME", ""),
                "password": os.getenv("SMTP_PASSWORD", "")
            }
            
            if not config.get("username") or not config.get("password"):
                return {
                    "success": False,
                    "error": "SMTP credentials not configured. Set SMTP_USERNAME and SMTP_PASSWORD environment variables.",
                    "action_taken": "Email content generated but not sent"
                }
            
            # Create email
            msg = MIMEMultipart()
            msg['From'] = config["username"]
            msg['To'] = recipient
            msg['Subject'] = subject
            msg.attach(MIMEText(body, 'plain'))
            
            # Send email
            with smtplib.SMTP(config["host"], config["port"]) as server:
                server.starttls()
                server.login(config["username"], config["password"])
                server.send_message(msg)
            
            result = {
                "success": True,
                "message": f"Email sent successfully to {recipient}",
                "recipient": recipient,
                "subject": subject
            }
            
            self.log_execution("email", {"recipient": recipient, "subject": subject}, result)
            return result
            
        except Exception as e:
            result = {
                "success": False,
                "error": str(e),
                "action_taken": "Email generation attempted but sending failed"
            }
            self.log_execution("email", {"recipient": recipient}, result)
            return result
    
    async def execute_file_task(
        self,
        file_path: str,
        content: str,
        mode: str = "write"
    ) -> Dict[str, Any]:
        """
        Execute file operation task
        
        Args:
            file_path: Path to file
            content: Content to write
            mode: Operation mode (write, append)
        
        Returns:
            Execution result
        """
        try:
            file_path_obj = Path(file_path)
            
            # Ensure directory exists
            file_path_obj.parent.mkdir(parents=True, exist_ok=True)
            
            if mode == "write":
                file_path_obj.write_text(content, encoding='utf-8')
                action = "created and written"
            elif mode == "append":
                with open(file_path_obj, 'a', encoding='utf-8') as f:
                    f.write(content)
                action = "appended to"
            else:
                return {
                    "success": False,
                    "error": f"Unknown mode: {mode}"
                }
            
            result = {
                "success": True,
                "message": f"File {action} successfully",
                "file_path": str(file_path_obj.absolute()),
                "size": len(content),
                "mode": mode
            }
            
            self.log_execution("file", {"file_path": file_path, "mode": mode}, result)
            return result
            
        except Exception as e:
            result = {
                "success": False,
                "error": str(e)
            }
            self.log_execution("file", {"file_path": file_path}, result)
            return result
    
    async def execute_browser_task(
        self,
        url: str,
        action: str = "open"
    ) -> Dict[str, Any]:
        """
        Execute browser task - open URL
        
        Args:
            url: URL to open
            action: Action to perform (open)
        
        Returns:
            Execution result (note: actual browser opening happens on frontend)
        """
        try:
            # Validate URL
            if not url.startswith(('http://', 'https://')):
                # Try to add https://
                if 'youtube.com' in url.lower() or 'youtu.be' in url.lower():
                    url = f"https://{url}" if not url.startswith('http') else url
                else:
                    url = f"https://{url}"
            
            result = {
                "success": True,
                "message": f"Browser action requested: {action} {url}",
                "url": url,
                "action": action,
                "frontend_action": "open_browser"  # Signal to frontend
            }
            
            self.log_execution("browser", {"url": url, "action": action}, result)
            return result
            
        except Exception as e:
            result = {
                "success": False,
                "error": str(e)
            }
            self.log_execution("browser", {"url": url}, result)
            return result
    
    async def execute_mcp_task(
        self,
        mcp_server: str,
        action: str,
        params: Dict[str, Any]
    ) -> Dict[str, Any]:
        """
        Execute MCP (Model Context Protocol) server task
        
        Args:
            mcp_server: MCP server identifier (e.g., "notion", "github")
            action: Action to perform
            params: Parameters for the action
        
        Returns:
            Execution result
        """
        try:
            # MCP server integration
            # This is a framework that can be extended with actual MCP client libraries
            
            result = {
                "success": True,
                "message": f"MCP task executed: {mcp_server}.{action}",
                "mcp_server": mcp_server,
                "action": action,
                "params": params,
                "note": "MCP integration requires MCP client setup"
            }
            
            self.log_execution("mcp", {"mcp_server": mcp_server, "action": action}, result)
            return result
            
        except Exception as e:
            result = {
                "success": False,
                "error": str(e)
            }
            self.log_execution("mcp", {"mcp_server": mcp_server}, result)
            return result
    
    async def execute_custom_task(
        self,
        task_type: str,
        task_data: Dict[str, Any]
    ) -> Dict[str, Any]:
        """
        Execute custom task
        
        Args:
            task_type: Type of custom task
            task_data: Task-specific data
        
        Returns:
            Execution result
        """
        try:
            # Handle various custom tasks
            if task_type == "wait":
                import asyncio
                await asyncio.sleep(task_data.get("seconds", 1))
                return {"success": True, "message": f"Waited {task_data.get('seconds')} seconds"}
            
            elif task_type == "command":
                # Execute shell command (use with caution)
                result = subprocess.run(
                    task_data.get("command", ""),
                    shell=True,
                    capture_output=True,
                    text=True,
                    timeout=task_data.get("timeout", 30)
                )
                return {
                    "success": result.returncode == 0,
                    "stdout": result.stdout,
                    "stderr": result.stderr,
                    "returncode": result.returncode
                }
            
            else:
                return {
                    "success": False,
                    "error": f"Unknown custom task type: {task_type}"
                }
                
        except Exception as e:
            return {
                "success": False,
                "error": str(e)
            }
    
    def get_execution_log(self) -> List[Dict]:
        """Get execution log"""
        return self.execution_log



